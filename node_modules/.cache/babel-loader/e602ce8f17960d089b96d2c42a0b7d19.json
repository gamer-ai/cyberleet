{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/ThreeViewer.js\";\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\n\nclass ThreeView extends Component {\n  constructor(...args) {\n    super(...args);\n\n    this.renderScene = () => {\n      // mouse and raycaster\n      this.raycaster.setFromCamera(this.mouse, this.camera); // calculate objects intersecting the picking ray\n\n      const intersects = this.raycaster.intersectObjects(this.cubesToBePicked);\n\n      if (intersects.length > 0) {\n        if (intersects[0].object != this.INTERSECTED) {\n          if (this.INTERSECTED) this.INTERSECTED.material.color.setHex(this.INTERSECTED.currentHex);\n          this.INTERSECTED = intersects[0].object;\n          this.INTERSECTED.currentHex = this.INTERSECTED.material.color.getHex();\n          this.INTERSECTED.material.color.setHex(0xFF00FF);\n        }\n      } else {\n        if (this.INTERSECTED) {\n          this.INTERSECTED.material.color.setHex(this.INTERSECTED.currentHex);\n        }\n\n        this.INTERSECTED = null;\n      } // this.frameId = window.requestAnimationFrame(this.animate);\n\n\n      window.requestAnimationFrame(this.renderScene); // if (this.renderer) this.renderer.render(this.scene, this.camera);\n\n      this.renderer.render(this.scene, this.camera);\n    };\n  }\n\n  componentDidMount() {\n    // ------ three.js START ------\n    var worldsize = 6000;\n    var camera, scene, renderer;\n    scene = new THREE.Scene(); // scene.background = new THREE.Color( 0xf0f0f0 );\n\n    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\n    renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    window.addEventListener(\"resize\", onWindowResize, false); // document.body.appendChild(renderer.domElement);\n\n    this.mount.appendChild(renderer.domElement);\n    const controls = new OrbitControls(camera, renderer.domElement);\n    camera.position.set(0, 2000, 1500);\n    controls.update(); // const light = new THREE.AmbientLight(0xfbfbfb); // white light\n    // scene.add(light);\n\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    let INTERSECTED;\n    var cubesToBePicked = [];\n    gridPlane();\n    blocksInitial(); //axes();\n\n    render();\n\n    function axes() {\n      //axes + origin (optional)\n      const axesHelper = new THREE.AxesHelper(20);\n      scene.add(axesHelper);\n      const origingeometry = new THREE.BoxGeometry(1, 1, 1);\n      const originmaterial = new THREE.MeshBasicMaterial({\n        color: \"white\"\n      });\n      const origin = new THREE.Mesh(origingeometry, originmaterial);\n      scene.add(origin);\n    }\n\n    function gridPlane() {\n      //grid + background plane\n      var plane = new THREE.Mesh(new THREE.PlaneGeometry(worldsize, worldsize, 1), new THREE.MeshBasicMaterial({\n        color: \"grey\",\n        opacity: 0.3,\n        transparent: true\n      }));\n      plane.rotation.set(-Math.PI / 2, 0, 0);\n      scene.add(plane); //grid\n\n      var size = 3000,\n          step = 40;\n      var geometry, material, line;\n\n      for (let i = -size; i <= size; i += step) {\n        if (i / step % 2 === 0) {\n          continue;\n        }\n\n        geometry = new THREE.Geometry();\n        material = new THREE.LineBasicMaterial({\n          color: \"purple\"\n        });\n        geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n        geometry.vertices.push(new THREE.Vector3(size, 0, i));\n        line = new THREE.LineSegments(geometry, material);\n        scene.add(line);\n      }\n\n      for (let i = -size; i <= size; i += step) {\n        if (i / step % 2 === 0) {\n          continue;\n        }\n\n        geometry = new THREE.Geometry();\n        material = new THREE.LineBasicMaterial({\n          color: \"green\"\n        });\n        geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n        geometry.vertices.push(new THREE.Vector3(i, 0, size));\n        line = new THREE.LineSegments(geometry, material);\n        scene.add(line);\n      }\n    }\n\n    function blocksInitial() {\n      // blocks\n      var offset = 2000,\n          side = 50,\n          sidegap = 80;\n\n      for (let i = 0; i < allQuestions.length; i += 1) {\n        var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n        var bottommaterial;\n\n        if (allQuestions[i][\"difficulty\"] === \"1\") {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0x00cc00\n          });\n        } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0xff9900\n          });\n        } else {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0xD63333\n          });\n        }\n\n        var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n        var row = Math.floor(questionIndex / side);\n        var col = questionIndex % side;\n        bottomgeometry.translate(col * sidegap - offset, 10, row * sidegap - offset);\n        var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n        scene.add(bottommesh);\n        cubesToBePicked.push(bottommesh);\n        window.addEventListener('mousemove', onMouseMove, false);\n      }\n    }\n\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function render() {\n      // update the picking ray with the camera and mouse position\n      // update the picking ray with the camera and mouse position\n      raycaster.setFromCamera(mouse, camera); // calculate objects intersecting the picking ray\n\n      const intersects = raycaster.intersectObjects(cubesToBePicked);\n\n      if (intersects.length > 0) {\n        // if the closest object intersected is not the currently stored intersection object\n        if (intersects[0].object != INTERSECTED) {\n          // restore previous intersection object (if it exists) to its original color\n          if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex); // store reference to closest object as current intersection object\n\n          INTERSECTED = intersects[0].object; // store color of closest object (for later restoration)\n\n          INTERSECTED.currentHex = INTERSECTED.material.color.getHex(); // set a new color for closest object\n\n          INTERSECTED.material.color.setHex(0xFF00FF);\n        }\n      } else // there are no intersections\n        {\n          // restore previous intersection object (if it exists) to its original color\n          if (INTERSECTED) {\n            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n          } // remove previous intersection object reference\n          //     by setting current intersection object to \"nothing\"\n\n\n          INTERSECTED = null;\n        }\n\n      requestAnimationFrame(render);\n      controls.update();\n      renderer.render(scene, camera);\n    }\n\n    function onMouseMove(event) {\n      // calculate mouse position in normalized device coordinates\n      // (-1 to +1) for both components\n      mouse.x = event.clientX / window.innerWidth * 2 - 1;\n      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    }\n  }\n\n  componentWillUnmount() {\n    this.mount.removeChild(this.renderer.domElement);\n  } //   start = () => {\n  //     if (!this.frameId) {\n  //       this.frameId = requestAnimationFrame(this.animate);\n  //     }\n  //   };\n  //   stop = () => {\n  //     cancelAnimationFrame(this.frameId);\n  //   };\n\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: mount => {\n        this.mount = mount;\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 252,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nexport default ThreeView;","map":{"version":3,"sources":["/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/ThreeViewer.js"],"names":["React","Component","ReactDOM","THREE","OrbitControls","allQuestions","ThreeView","renderScene","raycaster","setFromCamera","mouse","camera","intersects","intersectObjects","cubesToBePicked","length","object","INTERSECTED","material","color","setHex","currentHex","getHex","window","requestAnimationFrame","renderer","render","scene","componentDidMount","worldsize","Scene","PerspectiveCamera","innerWidth","innerHeight","WebGLRenderer","antialias","setSize","addEventListener","onWindowResize","mount","appendChild","domElement","controls","position","set","update","Raycaster","Vector2","gridPlane","blocksInitial","axes","axesHelper","AxesHelper","add","origingeometry","BoxGeometry","originmaterial","MeshBasicMaterial","origin","Mesh","plane","PlaneGeometry","opacity","transparent","rotation","Math","PI","size","step","geometry","line","i","Geometry","LineBasicMaterial","vertices","push","Vector3","LineSegments","offset","side","sidegap","questionIndex","Number","bottommaterial","bottomgeometry","row","floor","col","translate","bottommesh","onMouseMove","aspect","updateProjectionMatrix","event","x","clientX","y","clientY","componentWillUnmount","removeChild"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\n\nclass ThreeView extends Component {\n    componentDidMount() {\n        // ------ three.js START ------\n        var worldsize = 6000;\n        var camera, scene, renderer;\n        scene = new THREE.Scene();\n        // scene.background = new THREE.Color( 0xf0f0f0 );\n        camera = new THREE.PerspectiveCamera(\n          45,\n          window.innerWidth / window.innerHeight,\n          1,\n          10000\n        );\n    \n        renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        window.addEventListener(\"resize\", onWindowResize, false);\n        // document.body.appendChild(renderer.domElement);\n        this.mount.appendChild(renderer.domElement);\n        const controls = new OrbitControls(camera, renderer.domElement);\n        camera.position.set(0, 2000, 1500);\n        controls.update();\n        // const light = new THREE.AmbientLight(0xfbfbfb); // white light\n        // scene.add(light);\n    \n    \n        const raycaster = new THREE.Raycaster();\n        const mouse = new THREE.Vector2();\t\t\n        let INTERSECTED;\t\n    \n    \n    \n    \n        \n    \n        var cubesToBePicked = [];\n        gridPlane();\n        blocksInitial();\n      \n        //axes();\n        render();\n     \n    \n    \n        function axes(){\n          //axes + origin (optional)\n          const axesHelper = new THREE.AxesHelper( 20 );\n          scene.add( axesHelper );\n          const origingeometry = new THREE.BoxGeometry( 1, 1, 1 );\n          const originmaterial = new THREE.MeshBasicMaterial( {color: \"white\"} );\n          const origin = new THREE.Mesh( origingeometry, originmaterial );\n          scene.add( origin );\n        }\n        function gridPlane(){\n          //grid + background plane\n          var plane = new THREE.Mesh(\n            new THREE.PlaneGeometry(worldsize, worldsize, 1),\n            new THREE.MeshBasicMaterial({\n              color: \"grey\",\n              opacity: 0.3,\n              transparent: true,\n            })\n          );\n          plane.rotation.set(-Math.PI / 2, 0, 0);\n          scene.add(plane);\n          //grid\n          var size = 3000,\n            step = 40;\n          var geometry, material, line;\n          for (let i = -size; i <= size; i += step) {\n            if ((i / step) % 2 === 0) {\n              continue;\n            }\n            geometry = new THREE.Geometry();\n            material = new THREE.LineBasicMaterial({\n              color: \"purple\",\n            });\n            geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n            geometry.vertices.push(new THREE.Vector3(size, 0, i));\n            line = new THREE.LineSegments(geometry, material);\n            scene.add(line);\n          }\n          for (let i = -size; i <= size; i += step) {\n            if ((i / step) % 2 === 0) {\n              continue;\n            }\n            geometry = new THREE.Geometry();\n            material = new THREE.LineBasicMaterial({\n              color: \"green\",\n            });\n            geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n            geometry.vertices.push(new THREE.Vector3(i, 0, size));\n            line = new THREE.LineSegments(geometry, material);\n            scene.add(line);\n          }\n        }\n    \n    \n        \n        function blocksInitial() {\n          // blocks\n          var offset = 2000,\n            side = 50,\n            sidegap = 80;\n          for (let i = 0; i < allQuestions.length; i += 1) {\n            var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n            var bottommaterial;\n            if (allQuestions[i][\"difficulty\"] === \"1\") {\n              bottommaterial = new THREE.MeshBasicMaterial({ color: 0x00cc00 });\n            } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n              bottommaterial = new THREE.MeshBasicMaterial({ color: 0xff9900 });\n            } else {\n              bottommaterial = new THREE.MeshBasicMaterial({ color: 0xD63333 });\n            }\n            var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n            var row = Math.floor(questionIndex / side);\n            var col = questionIndex % side;\n            bottomgeometry.translate(\n              col * sidegap - offset,\n              10,\n              row * sidegap - offset\n            );\n            var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n            scene.add(bottommesh);\n            cubesToBePicked.push(bottommesh);\n            window.addEventListener( 'mousemove', onMouseMove, false );\n          }\n        }\n    \n        function onWindowResize() {\n          camera.aspect = window.innerWidth / window.innerHeight;\n          camera.updateProjectionMatrix();\n    \n          renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n    \n        function render() {\n              // update the picking ray with the camera and mouse position\n            // update the picking ray with the camera and mouse position\n            raycaster.setFromCamera( mouse, camera );\n      \n            // calculate objects intersecting the picking ray\n            const intersects = raycaster.intersectObjects( cubesToBePicked );\n            if ( intersects.length > 0 )\n            {\n                // if the closest object intersected is not the currently stored intersection object\n                if ( intersects[ 0 ].object != INTERSECTED )\n                {\n                    // restore previous intersection object (if it exists) to its original color\n                    if ( INTERSECTED )\n                        INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n                    // store reference to closest object as current intersection object\n                    INTERSECTED = intersects[ 0 ].object;\n                    // store color of closest object (for later restoration)\n                    INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n                    // set a new color for closest object\n                    INTERSECTED.material.color.setHex( 0xFF00FF );\n    \n                }\n            }\n            else // there are no intersections\n            {\n                // restore previous intersection object (if it exists) to its original color\n                if ( INTERSECTED ){\n                    INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n                  }\n                // remove previous intersection object reference\n                //     by setting current intersection object to \"nothing\"\n                \n                INTERSECTED = null;\n            \n            }\n    \n    \n          requestAnimationFrame(render);\n          controls.update();\n          renderer.render(scene, camera);\n        }\n    \n        function onMouseMove( event ) {\n          // calculate mouse position in normalized device coordinates\n          // (-1 to +1) for both components\n          mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n          mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n        \n        }\n        \n      }\n\n\n  componentWillUnmount() {\n    this.mount.removeChild(this.renderer.domElement);\n \n  }\n//   start = () => {\n//     if (!this.frameId) {\n//       this.frameId = requestAnimationFrame(this.animate);\n//     }\n//   };\n\n\n//   stop = () => {\n//     cancelAnimationFrame(this.frameId);\n//   };\n\n\n\n\n  renderScene = () => {\n    // mouse and raycaster\n    \n    this.raycaster.setFromCamera( this.mouse, this.camera );\n    // calculate objects intersecting the picking ray\n    const intersects = this.raycaster.intersectObjects( this.cubesToBePicked );\n    if ( intersects.length > 0 )\n    {\n        if ( intersects[ 0 ].object != this.INTERSECTED )\n        {\n            if ( this.INTERSECTED )\n                this.INTERSECTED.material.color.setHex( this.INTERSECTED.currentHex );\n            this.INTERSECTED = intersects[ 0 ].object;\n            this.INTERSECTED.currentHex = this.INTERSECTED.material.color.getHex();\n            this.INTERSECTED.material.color.setHex( 0xFF00FF );\n        }\n    }\n    else \n    {\n        if ( this.INTERSECTED ){\n            this.INTERSECTED.material.color.setHex( this.INTERSECTED.currentHex );\n          }\n        this.INTERSECTED = null;\n    }\n\n    // this.frameId = window.requestAnimationFrame(this.animate);\n\n    window.requestAnimationFrame(this.renderScene);\n\n    // if (this.renderer) this.renderer.render(this.scene, this.camera);\n    this.renderer.render(this.scene, this.camera);\n    \n\n  };\n\n  render() {\n    return (\n      <div\n        ref={mount => {\n          this.mount = mount;\n        }}\n      />\n    );\n  }\n}\nexport default ThreeView;"]},"metadata":{},"sourceType":"module"}