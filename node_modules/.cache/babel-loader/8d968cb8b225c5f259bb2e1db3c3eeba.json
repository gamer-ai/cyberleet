{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/ThreeViewer.js\";\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\n\nclass ThreeView extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      questionName: 'ss'\n    };\n  }\n\n  onMouseMove(event) {\n    mouse.x = event.clientX / window.innerWidth * 2 - 1;\n    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    raycaster.setFromCamera(mouse, camera);\n    const intersects = raycaster.intersectObjects(cubesToBePicked);\n\n    if (intersects.length > 0) {\n      if (intersects[0].object != INTERSECTED) {\n        if (INTERSECTED) INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n        INTERSECTED = intersects[0].object;\n        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n        INTERSECTED.material.color.setHex(0xFF00FF);\n      }\n    } else //no intesections\n      {\n        if (INTERSECTED) {\n          INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n        }\n\n        INTERSECTED = null;\n      }\n  }\n\n  componentDidMount() {\n    // --- three.js applied here ---\n    window.addEventListener(\"resize\", onWindowResize, false);\n    window.addEventListener('mousemove', onMouseMove, false);\n    var worldsize = 6000;\n    var camera, scene, renderer;\n    scene = new THREE.Scene(); // scene.background = new THREE.Color( 0xf0f0f0 );\n\n    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\n    renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight); // document.body.appendChild(renderer.domElement);\n\n    this.mount.appendChild(renderer.domElement);\n    const controls = new OrbitControls(camera, renderer.domElement);\n    camera.position.set(0, 2000, 1500);\n    controls.update(); // raycasting + mouse movement tracking\n\n    const raycaster = new THREE.Raycaster();\n    const mouse = new THREE.Vector2();\n    let INTERSECTED;\n    var cubesToBePicked = [];\n    gridPlane();\n    blocksInitial(); //axes();\n\n    render();\n\n    function axes() {\n      //axes + origin (optional)\n      const axesHelper = new THREE.AxesHelper(20);\n      scene.add(axesHelper);\n      const origingeometry = new THREE.BoxGeometry(1, 1, 1);\n      const originmaterial = new THREE.MeshBasicMaterial({\n        color: \"white\"\n      });\n      const origin = new THREE.Mesh(origingeometry, originmaterial);\n      scene.add(origin);\n    }\n\n    function gridPlane() {\n      //grid + background plane\n      var plane = new THREE.Mesh(new THREE.PlaneGeometry(worldsize, worldsize, 1), new THREE.MeshBasicMaterial({\n        color: \"grey\",\n        opacity: 0.3,\n        transparent: true\n      }));\n      plane.rotation.set(-Math.PI / 2, 0, 0);\n      scene.add(plane); //grid\n\n      var size = 3000,\n          step = 40;\n      var geometry, material, line;\n\n      for (let i = -size; i <= size; i += step) {\n        if (i / step % 2 === 0) {\n          continue;\n        }\n\n        geometry = new THREE.Geometry();\n        material = new THREE.LineBasicMaterial({\n          color: \"purple\"\n        });\n        geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n        geometry.vertices.push(new THREE.Vector3(size, 0, i));\n        line = new THREE.LineSegments(geometry, material);\n        scene.add(line);\n      }\n\n      for (let i = -size; i <= size; i += step) {\n        if (i / step % 2 === 0) {\n          continue;\n        }\n\n        geometry = new THREE.Geometry();\n        material = new THREE.LineBasicMaterial({\n          color: \"green\"\n        });\n        geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n        geometry.vertices.push(new THREE.Vector3(i, 0, size));\n        line = new THREE.LineSegments(geometry, material);\n        scene.add(line);\n      }\n    }\n\n    function blocksInitial() {\n      // blocks\n      var offset = 2000,\n          side = 50,\n          sidegap = 80;\n\n      for (let i = 0; i < allQuestions.length; i += 1) {\n        var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n        var bottommaterial;\n\n        if (allQuestions[i][\"difficulty\"] === \"1\") {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0x00cc00\n          });\n        } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0xff9900\n          });\n        } else {\n          bottommaterial = new THREE.MeshBasicMaterial({\n            color: 0xD63333\n          });\n        }\n\n        var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n        var row = Math.floor(questionIndex / side);\n        var col = questionIndex % side;\n        bottomgeometry.translate(col * sidegap - offset, 10, row * sidegap - offset);\n        var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n        scene.add(bottommesh);\n        cubesToBePicked.push(bottommesh);\n      }\n    }\n\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function render() {\n      requestAnimationFrame(render);\n      controls.update();\n      renderer.render(scene, camera);\n    } // function onMouseMove(event) {\n    //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n    //     mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n    //     raycaster.setFromCamera(mouse, camera);\n    //     const intersects = raycaster.intersectObjects(cubesToBePicked);\n    //     if (intersects.length > 0) {\n    //         if (intersects[0].object != INTERSECTED) {\n    //             if (INTERSECTED)\n    //                 INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n    //             INTERSECTED = intersects[0].object;\n    //             INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n    //             INTERSECTED.material.color.setHex(0xFF00FF);\n    //         }\n    //     }\n    //     else //no intesections\n    //     {\n    //         if (INTERSECTED) {\n    //             INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n    //         }\n    //         INTERSECTED = null;\n    //     }\n    // }\n    // --- three.js parts end ---\n\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n        children: [\"Hello \", this.state.questionName, \" \"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 200,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        id: \"ThreeView\",\n        ref: mount => {\n          this.mount = mount;\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 201,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 199,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nexport default ThreeView;","map":{"version":3,"sources":["/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/ThreeViewer.js"],"names":["React","Component","ReactDOM","THREE","OrbitControls","allQuestions","ThreeView","constructor","props","state","questionName","onMouseMove","event","mouse","x","clientX","window","innerWidth","y","clientY","innerHeight","raycaster","setFromCamera","camera","intersects","intersectObjects","cubesToBePicked","length","object","INTERSECTED","material","color","setHex","currentHex","getHex","componentDidMount","addEventListener","onWindowResize","worldsize","scene","renderer","Scene","PerspectiveCamera","WebGLRenderer","antialias","setSize","mount","appendChild","domElement","controls","position","set","update","Raycaster","Vector2","gridPlane","blocksInitial","render","axes","axesHelper","AxesHelper","add","origingeometry","BoxGeometry","originmaterial","MeshBasicMaterial","origin","Mesh","plane","PlaneGeometry","opacity","transparent","rotation","Math","PI","size","step","geometry","line","i","Geometry","LineBasicMaterial","vertices","push","Vector3","LineSegments","offset","side","sidegap","questionIndex","Number","bottommaterial","bottomgeometry","row","floor","col","translate","bottommesh","aspect","updateProjectionMatrix","requestAnimationFrame"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\n\nclass ThreeView extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = { questionName: 'ss' };\n      }\n\n      onMouseMove(event) {\n        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n        raycaster.setFromCamera(mouse, camera);\n        const intersects = raycaster.intersectObjects(cubesToBePicked);\n        if (intersects.length > 0) {\n            if (intersects[0].object != INTERSECTED) {\n                if (INTERSECTED)\n                    INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n                INTERSECTED = intersects[0].object;\n                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n                INTERSECTED.material.color.setHex(0xFF00FF);\n            }\n        }\n        else //no intesections\n        {\n            if (INTERSECTED) {\n                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n            }\n            INTERSECTED = null;\n        }\n\n    }\n    \n    componentDidMount() {\n        // --- three.js applied here ---\n        window.addEventListener(\"resize\", onWindowResize, false);\n        window.addEventListener('mousemove', onMouseMove, false);\n        var worldsize = 6000;\n        var camera, scene, renderer;\n        scene = new THREE.Scene();\n        // scene.background = new THREE.Color( 0xf0f0f0 );\n        camera = new THREE.PerspectiveCamera(\n            45,\n            window.innerWidth / window.innerHeight,\n            1,\n            10000\n        );\n        renderer = new THREE.WebGLRenderer({ antialias: true });\n        renderer.setSize(window.innerWidth, window.innerHeight);\n\n        // document.body.appendChild(renderer.domElement);\n        this.mount.appendChild(renderer.domElement);\n\n        const controls = new OrbitControls(camera, renderer.domElement);\n        camera.position.set(0, 2000, 1500);\n        controls.update();\n\n        // raycasting + mouse movement tracking\n        const raycaster = new THREE.Raycaster();\n        const mouse = new THREE.Vector2();\n        let INTERSECTED;\n        var cubesToBePicked = [];\n        gridPlane();\n        blocksInitial();\n        //axes();\n        render();\n\n        function axes() {\n            //axes + origin (optional)\n            const axesHelper = new THREE.AxesHelper(20);\n            scene.add(axesHelper);\n            const origingeometry = new THREE.BoxGeometry(1, 1, 1);\n            const originmaterial = new THREE.MeshBasicMaterial({ color: \"white\" });\n            const origin = new THREE.Mesh(origingeometry, originmaterial);\n            scene.add(origin);\n        }\n\n        function gridPlane() {\n            //grid + background plane\n            var plane = new THREE.Mesh(\n                new THREE.PlaneGeometry(worldsize, worldsize, 1),\n                new THREE.MeshBasicMaterial({\n                    color: \"grey\",\n                    opacity: 0.3,\n                    transparent: true,\n                })\n            );\n            plane.rotation.set(-Math.PI / 2, 0, 0);\n            scene.add(plane);\n            //grid\n            var size = 3000,\n                step = 40;\n            var geometry, material, line;\n            for (let i = -size; i <= size; i += step) {\n                if ((i / step) % 2 === 0) {\n                    continue;\n                }\n                geometry = new THREE.Geometry();\n                material = new THREE.LineBasicMaterial({\n                    color: \"purple\",\n                });\n                geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n                geometry.vertices.push(new THREE.Vector3(size, 0, i));\n                line = new THREE.LineSegments(geometry, material);\n                scene.add(line);\n            }\n            for (let i = -size; i <= size; i += step) {\n                if ((i / step) % 2 === 0) {\n                    continue;\n                }\n                geometry = new THREE.Geometry();\n                material = new THREE.LineBasicMaterial({\n                    color: \"green\",\n                });\n                geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n                geometry.vertices.push(new THREE.Vector3(i, 0, size));\n                line = new THREE.LineSegments(geometry, material);\n                scene.add(line);\n            }\n        }\n\n        function blocksInitial() {\n            // blocks\n            var offset = 2000,\n                side = 50,\n                sidegap = 80;\n            for (let i = 0; i < allQuestions.length; i += 1) {\n                var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n                var bottommaterial;\n                if (allQuestions[i][\"difficulty\"] === \"1\") {\n                    bottommaterial = new THREE.MeshBasicMaterial({ color: 0x00cc00 });\n                } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n                    bottommaterial = new THREE.MeshBasicMaterial({ color: 0xff9900 });\n                } else {\n                    bottommaterial = new THREE.MeshBasicMaterial({ color: 0xD63333 });\n                }\n                var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n                var row = Math.floor(questionIndex / side);\n                var col = questionIndex % side;\n                bottomgeometry.translate(\n                    col * sidegap - offset,\n                    10,\n                    row * sidegap - offset\n                );\n                var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n                scene.add(bottommesh);\n                cubesToBePicked.push(bottommesh);\n\n            }\n        }\n\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        }\n\n        function render() {\n            requestAnimationFrame(render);\n            controls.update();\n            renderer.render(scene, camera);\n        }\n     \n        // function onMouseMove(event) {\n        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n        //     mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;\n        //     raycaster.setFromCamera(mouse, camera);\n        //     const intersects = raycaster.intersectObjects(cubesToBePicked);\n        //     if (intersects.length > 0) {\n        //         if (intersects[0].object != INTERSECTED) {\n        //             if (INTERSECTED)\n        //                 INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n        //             INTERSECTED = intersects[0].object;\n        //             INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n        //             INTERSECTED.material.color.setHex(0xFF00FF);\n        //         }\n        //     }\n        //     else //no intesections\n        //     {\n        //         if (INTERSECTED) {\n        //             INTERSECTED.material.color.setHex(INTERSECTED.currentHex);\n        //         }\n        //         INTERSECTED = null;\n        //     }\n\n        // }\n        // --- three.js parts end ---\n\n    }\n\n\n    render() {\n        return (\n            <div>\n            <h1>Hello {this.state.questionName} </h1>\n            <div id = \"ThreeView\"\n            ref={mount => {\n                this.mount = mount;\n              }}\n              />\n            </div>\n        );\n    }\n}\nexport default ThreeView;"]},"metadata":{},"sourceType":"module"}