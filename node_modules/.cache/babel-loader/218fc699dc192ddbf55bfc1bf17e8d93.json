{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/index.js\";\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\nimport Swal from 'sweetalert2';\nimport App from './App'; // class App extends Component {\n//   componentDidMount() {\n//   //   // ------ three.js START ------\n//   //   var worldsize = 6000;\n//   //   var camera, scene, renderer;\n//   //   scene = new THREE.Scene();\n//   //   // scene.background = new THREE.Color( 0xf0f0f0 );\n//   //   camera = new THREE.PerspectiveCamera(\n//   //     45,\n//   //     window.innerWidth / window.innerHeight,\n//   //     1,\n//   //     10000\n//   //   );\n//   //   renderer = new THREE.WebGLRenderer({ antialias: true });\n//   //   renderer.setSize(window.innerWidth, window.innerHeight);\n//   //   window.addEventListener(\"resize\", onWindowResize, false);\n//   //   document.body.appendChild(renderer.domElement);\n//   //   const controls = new OrbitControls(camera, renderer.domElement);\n//   //   camera.position.set(0, 2000, 1500);\n//   //   controls.update();\n//   //   // const light = new THREE.AmbientLight(0xfbfbfb); // white light\n//   //   // scene.add(light);\n//   //   const raycaster = new THREE.Raycaster();\n//   //   const mouse = new THREE.Vector2();\t\t\n//   //   let INTERSECTED;\t\n//   //   var cubesToBePicked = [];\n//   //   gridPlane();\n//   //   blocksInitial();\n//   //   //axes();\n//   //   render();\n//   //   function axes(){\n//   //     //axes + origin (optional)\n//   //     const axesHelper = new THREE.AxesHelper( 20 );\n//   //     scene.add( axesHelper );\n//   //     const origingeometry = new THREE.BoxGeometry( 1, 1, 1 );\n//   //     const originmaterial = new THREE.MeshBasicMaterial( {color: \"white\"} );\n//   //     const origin = new THREE.Mesh( origingeometry, originmaterial );\n//   //     scene.add( origin );\n//   //   }\n//   //   function gridPlane(){\n//   //     //grid + background plane\n//   //     var plane = new THREE.Mesh(\n//   //       new THREE.PlaneGeometry(worldsize, worldsize, 1),\n//   //       new THREE.MeshBasicMaterial({\n//   //         color: \"grey\",\n//   //         opacity: 0.3,\n//   //         transparent: true,\n//   //       })\n//   //     );\n//   //     plane.rotation.set(-Math.PI / 2, 0, 0);\n//   //     scene.add(plane);\n//   //     //grid\n//   //     var size = 3000,\n//   //       step = 40;\n//   //     var geometry, material, line;\n//   //     for (let i = -size; i <= size; i += step) {\n//   //       if ((i / step) % 2 === 0) {\n//   //         continue;\n//   //       }\n//   //       geometry = new THREE.Geometry();\n//   //       material = new THREE.LineBasicMaterial({\n//   //         color: \"purple\",\n//   //       });\n//   //       geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n//   //       geometry.vertices.push(new THREE.Vector3(size, 0, i));\n//   //       line = new THREE.LineSegments(geometry, material);\n//   //       scene.add(line);\n//   //     }\n//   //     for (let i = -size; i <= size; i += step) {\n//   //       if ((i / step) % 2 === 0) {\n//   //         continue;\n//   //       }\n//   //       geometry = new THREE.Geometry();\n//   //       material = new THREE.LineBasicMaterial({\n//   //         color: \"green\",\n//   //       });\n//   //       geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n//   //       geometry.vertices.push(new THREE.Vector3(i, 0, size));\n//   //       line = new THREE.LineSegments(geometry, material);\n//   //       scene.add(line);\n//   //     }\n//   //   }\n//   //   function blocksInitial() {\n//   //     // blocks\n//   //     var offset = 2000,\n//   //       side = 50,\n//   //       sidegap = 80;\n//   //     for (let i = 0; i < allQuestions.length; i += 1) {\n//   //       var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n//   //       var bottommaterial;\n//   //       if (allQuestions[i][\"difficulty\"] === \"1\") {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0x00cc00 });\n//   //       } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0xff9900 });\n//   //       } else {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0xD63333 });\n//   //       }\n//   //       var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n//   //       var row = Math.floor(questionIndex / side);\n//   //       var col = questionIndex % side;\n//   //       bottomgeometry.translate(\n//   //         col * sidegap - offset,\n//   //         10,\n//   //         row * sidegap - offset\n//   //       );\n//   //       var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n//   //       bottommesh.name = allQuestions[i][\"name\"];\n//   //       scene.add(bottommesh);\n//   //       cubesToBePicked.push(bottommesh);\n//   //       window.addEventListener( 'mousemove', onMouseMove, false );\n//   //     }\n//   //   }\n//   //   function onWindowResize() {\n//   //     camera.aspect = window.innerWidth / window.innerHeight;\n//   //     camera.updateProjectionMatrix();\n//   //     renderer.setSize(window.innerWidth, window.innerHeight);\n//   //   }\n//   //   function render() {\n//   //     \t// update the picking ray with the camera and mouse position\n//   //       // update the picking ray with the camera and mouse position\n//   //       raycaster.setFromCamera( mouse, camera );\n//   //       // calculate objects intersecting the picking ray\n//   //       const intersects = raycaster.intersectObjects( cubesToBePicked );\n//   //       if ( intersects.length > 0 )\n//   //       {\n//   //           // if the closest object intersected is not the currently stored intersection object\n//   //           if ( intersects[ 0 ].object != INTERSECTED )\n//   //           {\n//   //               // restore previous intersection object (if it exists) to its original color\n//   //               if ( INTERSECTED )\n//   //                   INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n//   //               // store reference to closest object as current intersection object\n//   //               INTERSECTED = intersects[ 0 ].object;\n//   //               // store color of closest object (for later restoration)\n//   //               INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n//   //               // set a new color for closest object\n//   //               INTERSECTED.material.color.setHex( 0xFF00FF );\n//   //           }\n//   //       }\n//   //       else // there are no intersections\n//   //       {\n//   //           // restore previous intersection object (if it exists) to its original color\n//   //           if ( INTERSECTED ){\n//   //               INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n//   //             }\n//   //           // remove previous intersection object reference\n//   //           //     by setting current intersection object to \"nothing\"\n//   //           INTERSECTED = null;\n//   //       }\n//   //     requestAnimationFrame(render);\n//   //     controls.update();\n//   //     renderer.render(scene, camera);\n//   //   }\n//   //   function onMouseMove( event ) {\n//   //     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n//   //     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n//   //   }\n//   // }\n//   // // ------ three.js END ------\n//   render() {\n//     return <div />;\n//   }\n// }\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render( /*#__PURE__*/_jsxDEV(App, {}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 193,\n  columnNumber: 17\n}, this), rootElement);","map":{"version":3,"sources":["/Users/muyangguo/Desktop/webgl/WebglPrototype/cybergraph/src/index.js"],"names":["React","Component","ReactDOM","THREE","OrbitControls","allQuestions","Swal","App","rootElement","document","getElementById","render"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,IAAP,MAAiB,aAAjB;AACA,OAAOC,GAAP,MAAgB,OAAhB,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAGC,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAApB;AACAR,QAAQ,CAACS,MAAT,eAAgB,QAAC,GAAD;AAAA;AAAA;AAAA;AAAA,QAAhB,EAAyBH,WAAzB","sourcesContent":["import React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"./OrbitControls.js\";\nimport allQuestions from \"./data/all.json\";\nimport Swal from 'sweetalert2';\nimport App from './App';\n// class App extends Component {\n//   componentDidMount() {\n//   //   // ------ three.js START ------\n//   //   var worldsize = 6000;\n//   //   var camera, scene, renderer;\n//   //   scene = new THREE.Scene();\n//   //   // scene.background = new THREE.Color( 0xf0f0f0 );\n//   //   camera = new THREE.PerspectiveCamera(\n//   //     45,\n//   //     window.innerWidth / window.innerHeight,\n//   //     1,\n//   //     10000\n//   //   );\n\n//   //   renderer = new THREE.WebGLRenderer({ antialias: true });\n//   //   renderer.setSize(window.innerWidth, window.innerHeight);\n//   //   window.addEventListener(\"resize\", onWindowResize, false);\n//   //   document.body.appendChild(renderer.domElement);\n//   //   const controls = new OrbitControls(camera, renderer.domElement);\n//   //   camera.position.set(0, 2000, 1500);\n//   //   controls.update();\n//   //   // const light = new THREE.AmbientLight(0xfbfbfb); // white light\n//   //   // scene.add(light);\n//   //   const raycaster = new THREE.Raycaster();\n//   //   const mouse = new THREE.Vector2();\t\t\n//   //   let INTERSECTED;\t\n//   //   var cubesToBePicked = [];\n//   //   gridPlane();\n//   //   blocksInitial();\n  \n//   //   //axes();\n//   //   render();\n//   //   function axes(){\n//   //     //axes + origin (optional)\n//   //     const axesHelper = new THREE.AxesHelper( 20 );\n//   //     scene.add( axesHelper );\n//   //     const origingeometry = new THREE.BoxGeometry( 1, 1, 1 );\n//   //     const originmaterial = new THREE.MeshBasicMaterial( {color: \"white\"} );\n//   //     const origin = new THREE.Mesh( origingeometry, originmaterial );\n//   //     scene.add( origin );\n//   //   }\n//   //   function gridPlane(){\n//   //     //grid + background plane\n//   //     var plane = new THREE.Mesh(\n//   //       new THREE.PlaneGeometry(worldsize, worldsize, 1),\n//   //       new THREE.MeshBasicMaterial({\n//   //         color: \"grey\",\n//   //         opacity: 0.3,\n//   //         transparent: true,\n//   //       })\n//   //     );\n//   //     plane.rotation.set(-Math.PI / 2, 0, 0);\n//   //     scene.add(plane);\n//   //     //grid\n//   //     var size = 3000,\n//   //       step = 40;\n//   //     var geometry, material, line;\n//   //     for (let i = -size; i <= size; i += step) {\n//   //       if ((i / step) % 2 === 0) {\n//   //         continue;\n//   //       }\n//   //       geometry = new THREE.Geometry();\n//   //       material = new THREE.LineBasicMaterial({\n//   //         color: \"purple\",\n//   //       });\n//   //       geometry.vertices.push(new THREE.Vector3(-size, 0, i));\n//   //       geometry.vertices.push(new THREE.Vector3(size, 0, i));\n//   //       line = new THREE.LineSegments(geometry, material);\n//   //       scene.add(line);\n//   //     }\n//   //     for (let i = -size; i <= size; i += step) {\n//   //       if ((i / step) % 2 === 0) {\n//   //         continue;\n//   //       }\n//   //       geometry = new THREE.Geometry();\n//   //       material = new THREE.LineBasicMaterial({\n//   //         color: \"green\",\n//   //       });\n//   //       geometry.vertices.push(new THREE.Vector3(i, 0, -size));\n//   //       geometry.vertices.push(new THREE.Vector3(i, 0, size));\n//   //       line = new THREE.LineSegments(geometry, material);\n//   //       scene.add(line);\n//   //     }\n//   //   }\n\n//   //   function blocksInitial() {\n//   //     // blocks\n//   //     var offset = 2000,\n//   //       side = 50,\n//   //       sidegap = 80;\n//   //     for (let i = 0; i < allQuestions.length; i += 1) {\n//   //       var questionIndex = Number(allQuestions[i][\"id\"]) - 1;\n//   //       var bottommaterial;\n//   //       if (allQuestions[i][\"difficulty\"] === \"1\") {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0x00cc00 });\n//   //       } else if (allQuestions[i][\"difficulty\"] === \"2\") {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0xff9900 });\n//   //       } else {\n//   //         bottommaterial = new THREE.MeshBasicMaterial({ color: 0xD63333 });\n//   //       }\n//   //       var bottomgeometry = new THREE.BoxGeometry(60, 20, 60);\n//   //       var row = Math.floor(questionIndex / side);\n//   //       var col = questionIndex % side;\n//   //       bottomgeometry.translate(\n//   //         col * sidegap - offset,\n//   //         10,\n//   //         row * sidegap - offset\n//   //       );\n//   //       var bottommesh = new THREE.Mesh(bottomgeometry, bottommaterial);\n//   //       bottommesh.name = allQuestions[i][\"name\"];\n//   //       scene.add(bottommesh);\n//   //       cubesToBePicked.push(bottommesh);\n//   //       window.addEventListener( 'mousemove', onMouseMove, false );\n//   //     }\n//   //   }\n\n//   //   function onWindowResize() {\n//   //     camera.aspect = window.innerWidth / window.innerHeight;\n//   //     camera.updateProjectionMatrix();\n\n//   //     renderer.setSize(window.innerWidth, window.innerHeight);\n//   //   }\n\n//   //   function render() {\n//   //     \t// update the picking ray with the camera and mouse position\n//   //       // update the picking ray with the camera and mouse position\n//   //       raycaster.setFromCamera( mouse, camera );\n  \n//   //       // calculate objects intersecting the picking ray\n//   //       const intersects = raycaster.intersectObjects( cubesToBePicked );\n//   //       if ( intersects.length > 0 )\n//   //       {\n//   //           // if the closest object intersected is not the currently stored intersection object\n//   //           if ( intersects[ 0 ].object != INTERSECTED )\n//   //           {\n//   //               // restore previous intersection object (if it exists) to its original color\n//   //               if ( INTERSECTED )\n//   //                   INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n//   //               // store reference to closest object as current intersection object\n//   //               INTERSECTED = intersects[ 0 ].object;\n//   //               // store color of closest object (for later restoration)\n//   //               INTERSECTED.currentHex = INTERSECTED.material.color.getHex();\n//   //               // set a new color for closest object\n//   //               INTERSECTED.material.color.setHex( 0xFF00FF );\n\n\n\n\n//   //           }\n//   //       }\n//   //       else // there are no intersections\n//   //       {\n//   //           // restore previous intersection object (if it exists) to its original color\n//   //           if ( INTERSECTED ){\n//   //               INTERSECTED.material.color.setHex( INTERSECTED.currentHex );\n\n//   //             }\n//   //           // remove previous intersection object reference\n//   //           //     by setting current intersection object to \"nothing\"\n\n\n//   //           INTERSECTED = null;\n        \n//   //       }\n\n\n//   //     requestAnimationFrame(render);\n//   //     controls.update();\n//   //     renderer.render(scene, camera);\n//   //   }\n\n//   //   function onMouseMove( event ) {\n//   //     mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n//   //     mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n    \n//   //   }\n    \n//   // }\n\n//   // // ------ three.js END ------\n//   render() {\n//     return <div />;\n//   }\n// }\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"]},"metadata":{},"sourceType":"module"}